{"version":3,"file":"static/js/448.5906fd44.chunk.js","mappings":"mBAGO,SAASA,EACdC,EACAC,GAE4C,IAD5CC,EAAiBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,GAEhBG,EAA0BN,EAC9B,MAAMO,EAAcP,EAAWQ,KAAKC,GAAS,IAAIC,KAAKD,GAAME,YAC5D,IAAIC,EAAkC,KAClCC,EAAqCJ,GAASA,EAAKK,cAExC,SAAXb,IAAmBA,EAuEzB,SAAyBM,EAAuBL,GAC9C,MAAOa,EAASC,GAAWC,EAAUV,GAErC,IAAIW,EAAyB,OACzBF,EAAUD,EAAU,MAAsBb,IAAWgB,EAAa,OAClEF,EAAUD,EAAU,OAA2Bb,IAAWgB,EAAa,SACvEF,EAAUD,EAAU,OAA+Bb,IAAWgB,EAAa,WAC3EF,EAAUD,EAAU,QAA4Bb,IAAWgB,EAAa,QAE5E,OAAOA,CACT,CAjFkCC,CAAeZ,EAAaL,IAE7C,SAAXD,IAAmBY,EAAaJ,GAASA,EAAKW,cAAcC,YAEjD,YAAXpB,IACFY,EAAaJ,IACX,MAAMa,EAAOb,EAAKW,cAAcC,WAC1BE,EAAUC,KAAKC,MAAMhB,EAAKiB,WAAa,GAAK,EAClD,MAAM,GAANC,OAAUL,EAAI,MAAAK,OAAKJ,EAAO,GAIf,UAAXtB,IACFY,EAAaJ,IACX,MAAMa,EAAOb,EAAKW,cAAcC,WAC1BO,EAAQnB,EAAKoB,eAAe,UAAW,CAAED,MAAO,UACtD,MAAM,GAAND,OAAUL,EAAI,KAAAK,OAAIC,EAAK,GAIZ,QAAX3B,IACFY,EAAaJ,IACX,MAAMa,EAAOb,EAAKW,cAAcC,WAC1BO,EAAQnB,EAAKoB,eAAe,UAAW,CAAED,MAAO,UAChDE,EAAMrB,EAAKsB,UAAUV,WAC3B,MAAM,GAANM,OAAUL,EAAI,KAAAK,OAAIC,EAAK,KAAAD,OAAIG,EAAG,GAInB,SAAX7B,IACFY,EAAaJ,IACX,MAAMa,EAAOb,EAAKW,cAAcC,WAC1BO,EAAQnB,EAAKoB,eAAe,UAAW,CAAED,MAAO,UAChDE,EAAMrB,EAAKsB,UAAUV,WACrBW,EAAOvB,EAAKK,cAAcmB,MAAM,KAAK,GAAGA,MAAM,KAAK,GACzD,MAAM,GAANN,OAAUL,EAAI,KAAAK,OAAIC,EAAK,KAAAD,OAAIG,EAAG,KAAAH,OAAIK,EAAI,SAI3B,gBAAX/B,IACFY,EAAaJ,GACW,IAAIyB,KAAKC,eAAe,UAAW,CAAEP,MAAO,SAC7C3B,OAAOQ,GAG9BG,EAAS,CAAC,IAAIF,KAAK,cAAcC,UAAW,IAAID,KAAK,cAAcC,YAEtD,kBAAXV,IACFY,EAAaJ,GACW,IAAIyB,KAAKC,eAAe,UAAW,CAAEC,QAAS,SAC/CnC,OAAOQ,GAG9BG,EAAS,CAAC,IAAIF,KAAK,cAAcC,UAAW,IAAID,KAAK,cAAcC,YAEtD,eAAXV,IACFY,EAAaJ,GACW,IAAIyB,KAAKC,eAAe,UAAW,CAAEH,KAAM,UAAWK,QAAQ,IAC/DpC,OAAOQ,GAG9BG,EAAS,CAAC,IAAIF,KAAK,cAAcC,UAAW,IAAID,KAAK,cAAcC,YAGrEL,EAAgBC,EAAYC,KAAKC,GAASI,EAAU,IAAIH,KAAKD,MAC/C,MAAVG,IAAgBA,EAASK,EAAUV,IACvC,MAAM+B,EAiBR,SACE1B,EACA2B,EACA1B,GAIA,MAAM2B,EAAmC,CAAC,GACnCzB,EAASC,GAAWJ,EAK3B,IAAI6B,EAAyB,EACZ,SAAbF,IAAqBE,EAAiB,UACzB,YAAbF,IAAwBE,EAAiB,SACzC,CAAC,QAAS,eAAeC,SAASH,KAAWE,EAAiB,SAC9D,CAAC,MAAO,iBAAiBC,SAASH,KAAWE,EAAiB,OAC9D,CAAC,OAAQ,cAAcC,SAASH,KAAWE,EAAiB,MAEhE,GAAIA,EAAiB,EACnB,IAAK,IAAIE,EAAI5B,EAAS4B,GAAK3B,EAAS2B,GAAKF,EAAgB,CACvD,MACMG,EAAa/B,EADN,IAAIH,KAAKiC,SAEOtC,IAAzBmC,EAASI,KACbJ,EAASI,GAAcD,EACzB,CAGF,OAAOH,CACT,CA/CsDK,CAAejC,EAAQX,EAAQY,GAEnF,MAAO,CAACP,EAAegC,EACzB,CA8CA,SAASrB,EAAW6B,GAClB,IAAIC,EAAMD,EAAQ,GACdE,EAAMF,EAAQ,GAKlB,OAJAA,EAAQG,SAASC,IACXA,EAAKH,IAAKA,EAAMG,GAChBA,EAAKF,IAAKA,EAAME,EAAE,IAEjB,CAACH,EAAKC,EACf,CAEO,SAASG,EAAUC,GAExB,OADeA,EAAKnB,MAAM,KACZoB,QAAQC,GAAU,WAAWC,KAAKD,IAClD,CAEO,SAASE,EAAgBC,EAAoCC,GAClE,MAAMC,EAAcF,EAAMG,KAAKC,MAAMC,WAAWC,GAASA,EAAKX,OAASM,IACvE,GAAIC,EAAc,EAAG,MAAM,IAAIK,MAAM,UAADrC,OAAW8B,EAAMQ,GAAE,KAAAtC,OAAI+B,EAAM,eACjE,OAAOD,EAAMS,KAAKC,KAAK3D,KAAK4D,GAAQA,EAAIP,MAAMF,GAAaP,MAC7D,CAEO,SAASiB,EACdC,EACAvB,EACAC,EACAuB,EACAC,GAEA,GAAIzB,IAAQC,EAAK,OAAQuB,EAASC,GAAU,EAC5C,IAAIC,GAAUH,EAAQvB,IAAQC,EAAMD,GAEpC,OADA0B,EAASC,MAAMD,GAAU,EAAIA,EACtBA,GAAUD,EAASD,GAAUA,CACtC,CCxJOI,eAAeC,EACpBnB,EACAoB,GAEA,GAA+B,IAA3BpB,EAAMS,KAAKC,KAAK/D,OAAc,OAAO0E,EAAuBD,GAEhE,MAAME,EAoDR,SACEtB,EACAoB,GAEA,MAAME,EAAmD,CAAC,GAEpD,QAAEC,EAAO,UAAEC,GAmHnB,SACExB,EACAoB,GAEA,IAAIG,EAAUxB,EAAeC,EAAOoB,EAAcK,MAAMxB,QACxD,GAAuB,IAAnBsB,EAAQ5E,OACV,MAAM,IAAI4D,MAAM,YAADrC,OAAa8B,EAAMQ,GAAE,KAAAtC,OAAIkD,EAAcK,MAAMxB,OAAM,eAGpE,IAAIuB,EAAoD,UAGjB5E,IAAnCwE,EAAcK,MAAMC,cACpBH,EAASC,GAAalF,EAAWiF,EAASH,EAAcK,MAAMC,aAGlE,QAAmC9E,IAA/BwE,EAAcK,MAAME,OAAsB,CAC5CH,EAAY,CAAC,EAEb,IAAK,IAAItC,EAAI,EAAGA,EAAIkC,EAAcK,MAAME,OAAOhF,OAAQuC,IAAK,CAE1DsC,EADcJ,EAAcK,MAAME,OAAOzC,IACtBA,CACrB,CACF,CAEA,MAAO,CAAEqC,UAASC,YACpB,CA7IiCI,CAAS5B,EAAOoB,GACzCS,EAAS7B,EAAMS,KAAKC,KAAK3D,KAAK4D,GAAQA,EAAIH,KAC1CsB,OAC0BlF,IAA9BwE,EAAcK,MAAMM,MAAsBX,EAAcK,MAAMM,MAAQX,EAAcK,MAAMxB,OAEtF+B,EAAeZ,EAAca,OAAOC,MAAMrB,IAA8B,IAApBA,EAAMsB,YAChE,GAAIH,GAA6B,MAAbR,EAClB,IAAK,MAAOY,EAAaC,KAAWC,OAAOC,QAAQf,GACjDF,EAAUc,GAAe,CACvBI,OAAQH,EACRR,OAAQ,CAAC,EACTC,SACAW,OAAQL,EACRH,OAAQ,CAAC,EACTS,YAAY,EACZC,aAAc,WAKpB,IAAK,MAAM9B,KAASO,EAAca,OAAQ,CAAC,IAADW,EAGxC,MAAMC,OAA6BjG,IAApBiE,EAAMS,UAA0BT,EAAMS,UAAY,QACjE,IAAIqB,EAA6B,UAClB,QAAXE,GAA+B,cAAXA,IAAwBF,EAAe,WAE/D,MAAMG,EAAU/C,EAAeC,EAAOa,EAAMZ,QAC5C,GAAuB,IAAnB6C,EAAQnG,OAAc,MAAM,IAAI4D,MAAM,YAADrC,OAAa8B,EAAMQ,GAAE,KAAAtC,OAAI2C,EAAMZ,OAAM,eAG9E,MAAM8C,OAA4BnG,IAAnBiE,EAAMmC,SAAyBjD,EAAeC,EAAOa,EAAMmC,UAAY,KAGhFb,EAA2B,QAAlBS,EAAG/B,EAAMsB,iBAAS,IAAAS,GAAAA,EAC3BK,EAA2D,CAAC,EAElE,IAAK,IAAI/D,EAAI,EAAGA,EAAI2C,EAAOlF,OAAQuC,IAAK,CAAC,IAADgE,EAEtC,MAAMT,EAASlB,EAAQrC,GAEvB,QAAkCtC,IAA9BwE,EAAcK,MAAM0B,QAEpBC,OAAOX,GAAUrB,EAAcK,MAAM0B,MAAM,IAC3CC,OAAOX,GAAUrB,EAAcK,MAAM0B,MAAM,IAE3C,SAWJ,MAAME,EAASP,EAAQ5D,GACjB6C,OAAwBnF,IAAhBiE,EAAMkB,MAAsBlB,EAAMkB,MAAQlB,EAAMZ,OACxDwB,EAAkB,MAAVsB,EAAiBA,EAAO7D,GAAK6C,EAErCS,EAAsB,MAAbhB,EAAoBA,EAAUiB,GAAUlB,EAAQrC,GAuBC,IAADoE,EAA/D,QApB4B1G,IAAxBqG,EAAaxB,KAAsBwB,EAAaxB,GAAS,CAAE8B,EAAG,EAAGC,IAAK,IAC3D,cAAXX,GAAqC,SAAXA,IAAmBI,EAAaxB,GAAO8B,GAAK,GAC3D,QAAXV,IAAkBI,EAAaxB,GAAO+B,KAAqB,QAAlBN,EAAIE,OAAOC,UAAO,IAAAH,EAAAA,EAAI,QAEzCtG,IAAtB0E,EAAUmB,KACZnB,EAAUmB,GAAU,CAClBD,OAAQA,EACRX,OAAQ,CAAC,EACTC,SACAW,OAAQgB,OAAOhB,GACfR,OAAQ,CAAC,EACTS,WAAY7B,EAAM6B,WAClBC,sBAGoC/F,IAApC0E,EAAUmB,GAAQZ,OAAOJ,KAAsBH,EAAUmB,GAAQZ,OAAOJ,GAAS,IACrFH,EAAUmB,GAAQZ,OAAOJ,GAAOiC,KAAK7B,EAAO3C,SAEJtC,IAApC0E,EAAUmB,GAAQR,OAAOR,KAAsBH,EAAUmB,GAAQR,OAAOR,GAAS,GACtE,UAAXoB,GAAiC,cAAXA,IAAwBvB,EAAUmB,GAAQR,OAAOR,IAAU,GACtE,QAAXoB,GAA+B,SAAXA,GAAgC,QAAXA,EAC3CvB,EAAUmB,GAAQR,OAAOR,IAAwB,QAAlB6B,EAAIF,OAAOC,UAAO,IAAAC,EAAAA,EAAI,CAEzD,CAGAhB,OAAOqB,KAAKV,GAAczD,SAASiC,IACjC,IAAK,MAAMgB,KAAUH,OAAOqB,KAAKrC,GAAY,CAC3C,QAAwC1E,IAApC0E,EAAUmB,GAAQR,OAAOR,GAAsB,CACjD,IAAIU,EACC,SADUb,EAAUmB,GAAQR,OAAOR,GAAS,CAEnD,CACe,SAAXoB,IACFvB,EAAUmB,GAAQR,OAAOR,GACvB2B,OAAO9B,EAAUmB,GAAQR,OAAOR,IAAUwB,EAAaxB,GAAO8B,GAEnD,cAAXV,IACFvB,EAAUmB,GAAQR,OAAOR,GACtB,IAAM2B,OAAO9B,EAAUmB,GAAQR,OAAOR,IAAWwB,EAAaxB,GAAO8B,GAE3D,QAAXV,IACFvB,EAAUmB,GAAQR,OAAOR,GACtB,IAAM2B,OAAO9B,EAAUmB,GAAQR,OAAOR,IAAWwB,EAAaxB,GAAO+B,IAE5E,IAEJ,CAEA,OAAOlC,CACT,CA3KoBsC,CAAc5D,EAAOoB,GACvC,OAGF,SACEA,EACAE,GAEA,MAAMuC,EAAoBxC,EAAuBD,GAEjD,IAAK,MAAM0C,KAAWxB,OAAOL,OAAOX,GAClC,IAAK,MAAMG,KAASa,OAAOqB,KAAKG,EAAQ7B,aACCrF,IAAnCiH,EAAkBE,MAAMtC,KAC1BoC,EAAkBE,MAAMtC,GAAS,CAC/BM,MAAON,EACPiB,WAAYoB,EAAQpB,WACpBC,aAAcmB,EAAQnB,eAmB9B,OAbAkB,EAAkBG,KAAO1B,OAAOL,OAAOX,GACpC2C,MAAK,CAACC,EAAQC,IAAYD,EAAE1B,OAAS2B,EAAE3B,QAAU,EAAI2B,EAAE3B,OAAS0B,EAAE1B,OAAS,EAAI,IAC/EzF,KAAKqH,IACJ,IAAK,MAAMC,KAAO/B,OAAOqB,KAAKS,EAAEnC,QAASmC,EAAEnC,OAAOoC,GAAOtG,KAAKuG,MAAsB,IAAhBF,EAAEnC,OAAOoC,IAAc,IAE3F,MAAO,IACFD,EAAEnC,OACL,CAACmC,EAAEtC,QAASsC,EAAE3B,OACd8B,SAAUH,EAAEvC,OACZ2C,SAAUJ,EAAE5B,OACb,IAGEqB,CACT,CAnCSY,CAAwBrD,EAAeE,EAChD,CAoCA,SAASD,EAAwBD,GAC/B,MAAO,CACLsD,KAAMtD,EAAcsD,KACpBC,KAAM,CACJ5C,WACgCnF,IAA9BwE,EAAcK,MAAMM,MAChBX,EAAcK,MAAMM,MACpBX,EAAcK,MAAMxB,QAE5B8D,MAAO,CAAC,EACRC,KAAM,GAEV,CCnDO9C,eAAe0D,EACpB5E,EACAoB,GAEA,MAAMyC,EAA2C,CAC/Ca,KAAMtD,EAAcsD,KACpBG,SAAU,IAGZ,GAA+B,IAA3B7E,EAAMS,KAAKC,KAAK/D,OAAc,OAAOkH,EAEzC,MAAMiB,EAAQ/E,EAAeC,EAAOoB,EAAc2D,YAI5CC,EAMR,SACEF,EACA7C,EACAb,GAEA,MAAM4D,EAA8C,CAAC,EAErD,IAAK,IAAI9F,EAAI,EAAGA,EAAI4F,EAAMnI,OAAQuC,IAAK,CACrC,GAAkB,OAAT,OAAL4F,QAAK,IAALA,OAAK,EAALA,EAAQ5F,IAAY,SACxB,MAAMS,EAAOmF,EAAM5F,GACb+F,EACsB,MAA1B7D,EAAc1B,UAAoB0B,EAAc1B,SAAWA,EAASC,GAAQ,CAACA,GAEzEuF,EAAO,IAAIC,IACjB,IAAK,MAAMtF,KAASoF,EAAQ,CAAC,IAAD/B,OACAtG,IAAtBoI,EAAWnF,KAAsBmF,EAAWnF,GAAS,CAAEgB,MAAO,EAAGuE,QAAS,IACzEF,EAAKG,IAAIxF,KACZmF,EAAWnF,GAAOuF,SAAW,EAC7BF,EAAKI,IAAIzF,IAEX,MAAM0F,EAAuB,QAAtBrC,EAAGE,OAAa,OAANnB,QAAM,IAANA,OAAM,EAANA,EAAS/C,WAAG,IAAAgE,EAAAA,EAAI,EAC5BjC,MAAMsE,KAAIP,EAAWnF,GAAOgB,OAAS0E,EAC5C,CACF,CAEA,GAAuC,SAAnCnE,EAAcoE,iBAChB,IAAK,MAAM3F,KAASyC,OAAOqB,KAAKqB,GAC9BA,EAAWnF,GAAOgB,OAASmE,EAAWnF,GAAOuF,QAGjD,OAAOJ,CACT,CArCqBS,CAAcX,EAFF,MAA7B1D,EAAcsE,YAAsB3F,EAAeC,EAAOoB,EAAcsE,aAAe,KAEzCtE,GAGhD,OAFAyC,EAAkBgB,SAsCpB,SACEG,EACAW,EACAd,GAEe,IADfe,IAAelJ,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAEfmJ,QAAQC,IAAI,QACZ,MAAMC,EAAQzD,OAAOC,QAAQyC,GAC1BjI,KAAIiJ,IAAoB,IAAlBrG,EAAMsG,GAAMD,EACjB,MAAME,EAAKnI,KAAK+H,IAAI,EAAIG,EAAMpF,OACxBsF,EAAMP,EAAS7H,KAAK+H,IAAIH,EAAQM,EAAMb,SAAW,KAAQ,EAC/D,MAAO,CAAEzF,OAAMkB,MAAOoF,EAAMpF,MAAOuF,WAAYF,EAAKC,EAAK,IAE1DlC,MAAK,CAACC,EAAGC,IAAMA,EAAEiC,WAAalC,EAAEkC,aAChCC,MAAM,EAAGxB,GAENyB,EAAgBvI,KAAKuB,OAAOyG,EAAMhJ,KAAKwJ,GAAMA,EAAEH,cAC/CI,EAAgBzI,KAAKwB,OAAOwG,EAAMhJ,KAAKwJ,GAAMA,EAAEH,cAErD,OAAOL,EAAMhJ,KAAKwJ,IACT,CACL5G,KAAM4G,EAAE5G,KACRkB,MAAO0F,EAAE1F,MACTuF,WAAYxF,EAAe2F,EAAEH,WAAYE,EAAeE,EAAe,EAAG,MAGhF,CAhE+BC,CAAYzB,EAAYF,EAAMnI,OAAQ,IAAKyE,EAAc1B,UAE/EmE,CACT,CCjBA6C,KAAKC,UAAaC,KAWlB1F,eACElB,EACAoB,GAEA,QAAcxE,IAAVoD,QAAyCpD,IAAlBwE,EAA6B,MAAM,IAAIb,MAAM,wCAExE,GAAI,CAAC,OAAQ,MAAO,QAAQtB,SAASmC,EAAcsD,MAAS,aAAavD,EAAiBnB,EAAOoB,GAEjG,GAAI,CAAC,aAAanC,SAASmC,EAAcsD,MAAS,aAAaE,EAAgB5E,EAAOoB,GAEtF,MAAM,IAAIb,MAAM,sBAADrC,OAAuBkD,EAAcsD,KAAI,kBAC1D,EArBED,CAAwBmC,EAAE5C,KAAKhE,MAAO4G,EAAE5C,KAAK5C,eAC1CyF,MAAMhD,IACL6C,KAAKI,YAAY,CAAEC,OAAQ,UAAWlD,qBAAoB,IAE3DmD,OAAOC,IACNpB,QAAQoB,MAAMA,GACdP,KAAKI,YAAY,CAAEC,OAAQ,QAASlD,uBAAmBjH,GAAY,GACnE,C","sources":["framework/visualisation/react/ui/workers/visualizationDataFunctions/util.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareChartData.ts","framework/visualisation/react/ui/workers/visualizationDataFunctions/prepareTextData.ts","framework/visualisation/react/ui/workers/visualizationDataWorker.ts"],"sourcesContent":["import { PropsUITable, TableContext } from '../../../../../types/elements'\nimport { DateFormat } from '../../../../../types/visualizations'\n\nexport function formatDate (\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString\n  const dateNumbers = dateString.map((date) => new Date(date).getTime())\n  let domain: [number, number] | null = null\n  let formatter: (date: Date) => string = (date) => date.toISOString()\n\n  if (format === 'auto') format = autoFormatDate(dateNumbers, minValues)\n\n  if (format === 'year') formatter = (date) => date.getFullYear().toString()\n\n  if (format === 'quarter') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const quarter = Math.floor(date.getMonth() / 3) + 1\n      return `${year}-Q${quarter}`\n    }\n  }\n\n  if (format === 'month') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      return `${year}-${month}`\n    }\n  }\n\n  if (format === 'day') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      const day = date.getDate().toString()\n      return `${year}-${month}-${day}`\n    }\n  }\n\n  if (format === 'hour') {\n    formatter = (date) => {\n      const year = date.getFullYear().toString()\n      const month = date.toLocaleString('default', { month: 'short' })\n      const day = date.getDate().toString()\n      const hour = date.toISOString().split('T')[1].split(':')[0]\n      return `${year}-${month}-${day} ${hour}:00`\n    }\n  }\n\n  if (format === 'month_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { month: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any year, starting at january\n    domain = [new Date('2000-01-01').getTime(), new Date('2001-01-01').getTime()]\n  }\n  if (format === 'weekday_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { weekday: 'long' })\n      return intlFormatter.format(date)\n    }\n    // can be any full week, starting at monday\n    domain = [new Date('2023-11-06').getTime(), new Date('2023-11-13').getTime()]\n  }\n  if (format === 'hour_cycle') {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat('default', { hour: 'numeric', hour12: false })\n      return intlFormatter.format(date)\n    }\n    // can be any day, starting at midnight\n    domain = [new Date('2000-01-01').getTime(), new Date('2000-01-02').getTime()]\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)))\n  if (domain == null) domain = getDomain(dateNumbers)\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter)\n\n  return [formattedDate, sortableDate]\n}\n\nfunction autoFormatDate (dateNumbers: number[], minValues: number): DateFormat {\n  const [minTime, maxTime] = getDomain(dateNumbers)\n\n  let autoFormat: DateFormat = 'hour'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = 'day'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = 'month'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = 'quarter'\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = 'year'\n\n  return autoFormat\n}\n\nfunction createSortable (\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {}\n  const [minTime, maxTime] = domain\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0\n  if (interval === 'year') intervalNumber = 1000 * 60 * 60 * 24 * 364\n  if (interval === 'quarter') intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3\n  if (['month', 'month_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28\n  if (['day', 'weekday_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24\n  if (['hour', 'hour_cycle'].includes(interval)) intervalNumber = 1000 * 60 * 60\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i)\n      const datestring = formatter(date)\n      if (sortable[datestring] !== undefined) continue\n      sortable[datestring] = i\n    }\n  }\n\n  return sortable\n}\n\nfunction getDomain (numbers: number[]): [number, number] {\n  let min = numbers[0]\n  let max = numbers[0]\n  numbers.forEach((nr) => {\n    if (nr < min) min = nr\n    if (nr > max) max = nr\n  })\n  return [min, max]\n}\n\nexport function tokenize (text: string): string[] {\n  const tokens = text.split(' ')\n  return tokens.filter((token) => /\\p{L}/giu.test(token)) // only tokens with word characters\n}\n\nexport function getTableColumn (table: PropsUITable & TableContext, column: string): string[] {\n  const columnIndex = table.head.cells.findIndex((cell) => cell.text === column)\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`)\n  return table.body.rows.map((row) => row.cells[columnIndex].text)\n}\n\nexport function rescaleToRange (\n  value: number,\n  min: number,\n  max: number,\n  newMin: number,\n  newMax: number\n): number {\n  if (min === max) return (newMin + newMax) / 2\n  let scaled = (value - min) / (max - min)\n  scaled = isNaN(scaled) ? 0 : scaled\n  return scaled * (newMax - newMin) + newMin\n}\n\nexport function extractUrlDomain (x: string): string {\n  let domain\n  try {\n    const url = new URL(x)\n    domain = url.hostname.replace(/^www\\./, '').replace(/^m\\./, '')\n  } catch (_) {\n    domain = x\n  }\n  return domain.trim()\n}\n","import { formatDate, getTableColumn } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TickerFormat,\n  ChartVisualizationData,\n  ChartVisualization\n} from '../../../../../types/visualizations'\n\nexport async function prepareChartData (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return emptyVisualizationData(visualization)\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(visualization, aggregate)\n}\n\nfunction createVisualizationData (\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = emptyVisualizationData(visualization)\n\n  for (const aggdata of Object.values(aggregate)) {\n    for (const group of Object.keys(aggdata.values)) {\n      if (visualizationData.yKeys[group] === undefined) {\n        visualizationData.yKeys[group] = {\n          label: group,\n          secondAxis: aggdata.secondAxis,\n          tickerFormat: aggdata.tickerFormat\n        }\n      }\n    }\n  }\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        [d.xLabel]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction emptyVisualizationData (visualization: ChartVisualization): ChartVisualizationData {\n  return {\n    type: visualization.type,\n    xKey: {\n      label:\n        visualization.group.label !== undefined\n          ? visualization.group.label\n          : visualization.group.column\n    },\n    yKeys: {},\n    data: []\n  }\n}\n\nfunction aggregateData (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xLabel =\n    visualization.group.label !== undefined ? visualization.group.label : visualization.group.column\n\n  const anyAddZeroes = visualization.values.some((value) => value.addZeroes === true)\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xLabel,\n        xValue: uniqueValue,\n        values: {},\n        secondAxis: false,\n        tickerFormat: 'default'\n      }\n    }\n  }\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n    let tickerFormat: TickerFormat = 'default'\n    if (aggFun === 'pct' || aggFun === 'count_pct') tickerFormat = 'percent'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by columns\n    const yGroup = value.group_by !== undefined ? getTableColumn(table, value.group_by) : null\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (\n          Number(xValue) < visualization.group.range[0] ||\n          Number(xValue) > visualization.group.range[1]\n        ) {\n          continue\n        }\n      }\n\n      // SHOULD GROUP BE IGNORED IF NOT IN group.levels? MAYBE NOT, BECAUSE\n      // THIS COULD HARM INFORMED CONSENT IF THE RESEARCHER IS UNAWARE OF CERTAIN GROUPS\n      // if (visualization.group.levels !== undefined) {\n      //   // formatLevels has xSortable < 0 if no match with levels\n      //   if (xSortable !== null && xSortable[i] < 0) continue\n      // }\n\n      const yValue = yValues[i]\n      const label = value.label !== undefined ? value.label : value.column\n      const group = yGroup != null ? yGroup[i] : label\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xLabel,\n          xValue: String(xValue),\n          values: {},\n          secondAxis: value.secondAxis,\n          tickerFormat\n        }\n      }\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] =\n            Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] =\n            (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  return aggregate\n}\n\nfunction prepareX (\n  table: PropsUITable & TableContext,\n  visualization: ChartVisualization\n): { groupBy: string[], xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xLabel: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  secondAxis?: boolean\n  tickerFormat?: TickerFormat\n}\n","import { getTableColumn, rescaleToRange, tokenize } from './util'\nimport { PropsUITable, TableContext } from '../../../../../types/elements'\nimport {\n  TextVisualizationData,\n  TextVisualization,\n  ScoredTerm\n} from '../../../../../types/visualizations'\n\ninterface VocabularyStats {\n  value: number\n  docFreq: number\n}\n\nexport async function prepareTextData (\n  table: PropsUITable & TableContext,\n  visualization: TextVisualization\n): Promise<TextVisualizationData> {\n  const visualizationData: TextVisualizationData = {\n    type: visualization.type,\n    topTerms: []\n  }\n\n  if (table.body.rows.length === 0) return visualizationData\n\n  const texts = getTableColumn(table, visualization.textColumn)\n  const values =\n    visualization.valueColumn != null ? getTableColumn(table, visualization.valueColumn) : null\n\n  const vocabulary = getVocabulary(texts, values, visualization)\n  visualizationData.topTerms = getTopTerms(vocabulary, texts.length, 200, visualization.tokenize)\n\n  return visualizationData\n}\n\nfunction getVocabulary (\n  texts: string[],\n  values: string[] | null,\n  visualization: TextVisualization\n): Record<string, VocabularyStats> {\n  const vocabulary: Record<string, VocabularyStats> = {}\n\n  for (let i = 0; i < texts.length; i++) {\n    if (texts?.[i] == null) continue\n    const text = texts[i]\n    const tokens =\n      visualization.tokenize != null && visualization.tokenize ? tokenize(text) : [text]\n\n    const seen = new Set<string>()\n    for (const token of tokens) {\n      if (vocabulary[token] === undefined) vocabulary[token] = { value: 0, docFreq: 0 }\n      if (!seen.has(token)) {\n        vocabulary[token].docFreq += 1\n        seen.add(token)\n      }\n      const v = Number(values?.[i]) ?? 1\n      if (!isNaN(v)) vocabulary[token].value += v\n    }\n  }\n\n  if (visualization.valueAggregation === 'mean') {\n    for (const token of Object.keys(vocabulary)) {\n      vocabulary[token].value /= vocabulary[token].docFreq\n    }\n  }\n  return vocabulary\n}\n\nfunction getTopTerms (\n  vocabulary: Record<string, VocabularyStats>,\n  nDocs: number,\n  topTerms: number,\n  useIdf: boolean = true\n): ScoredTerm[] {\n  console.log('hhhh')\n  const words = Object.entries(vocabulary)\n    .map(([text, stats]) => {\n      const tf = Math.log(1 + stats.value)\n      const idf = useIdf ? Math.log(nDocs / stats.docFreq) + 0.001 : 1\n      return { text, value: stats.value, importance: tf * idf }\n    })\n    .sort((a, b) => b.importance - a.importance)\n    .slice(0, topTerms)\n\n  const minImportance = Math.min(...words.map((w) => w.importance))\n  const maxImportance = Math.max(...words.map((w) => w.importance))\n\n  return words.map((w) => {\n    return {\n      text: w.text,\n      value: w.value,\n      importance: rescaleToRange(w.importance, minImportance, maxImportance, 0, 1)\n    }\n  })\n}\n","import { PropsUITable, TableContext, TableWithContext } from '../../../../types/elements'\nimport {\n  ChartVisualization,\n  TextVisualization,\n  VisualizationType,\n  VisualizationData\n} from '../../../../types/visualizations'\nimport { prepareChartData } from './visualizationDataFunctions/prepareChartData'\nimport { prepareTextData } from './visualizationDataFunctions/prepareTextData'\n\ninterface Input {\n  table: TableWithContext\n  visualization: VisualizationType\n}\n\nself.onmessage = (e: MessageEvent<Input>) => {\n  createVisualizationData(e.data.table, e.data.visualization)\n    .then((visualizationData) => {\n      self.postMessage({ status: 'success', visualizationData })\n    })\n    .catch((error) => {\n      console.error(error)\n      self.postMessage({ status: 'error', visualizationData: undefined })\n    })\n}\n\nasync function createVisualizationData (\n  table: PropsUITable & TableContext,\n  visualization: VisualizationType\n): Promise<VisualizationData> {\n  if (table === undefined || visualization === undefined) throw new Error('Table and visualization are required')\n\n  if (['line', 'bar', 'area'].includes(visualization.type)) { return await prepareChartData(table, visualization as ChartVisualization) }\n\n  if (['wordcloud'].includes(visualization.type)) { return await prepareTextData(table, visualization as TextVisualization) }\n\n  throw new Error(`Visualization type ${visualization.type} not supported`)\n}\n"],"names":["formatDate","dateString","format","minValues","arguments","length","undefined","formattedDate","dateNumbers","map","date","Date","getTime","domain","formatter","toISOString","minTime","maxTime","getDomain","autoFormat","autoFormatDate","getFullYear","toString","year","quarter","Math","floor","getMonth","concat","month","toLocaleString","day","getDate","hour","split","Intl","DateTimeFormat","weekday","hour12","sortableDate","interval","sortable","intervalNumber","includes","i","datestring","createSortable","numbers","min","max","forEach","nr","tokenize","text","filter","token","test","getTableColumn","table","column","columnIndex","head","cells","findIndex","cell","Error","id","body","rows","row","rescaleToRange","value","newMin","newMax","scaled","isNaN","async","prepareChartData","visualization","emptyVisualizationData","aggregate","groupBy","xSortable","group","dateFormat","levels","prepareX","rowIds","xLabel","label","anyAddZeroes","values","some","addZeroes","uniqueValue","sortby","Object","entries","sortBy","xValue","secondAxis","tickerFormat","_value$addZeroes","aggFun","yValues","yGroup","group_by","groupSummary","_Number","range","Number","yValue","_Number2","n","sum","String","push","keys","aggregateData","visualizationData","aggdata","yKeys","data","sort","a","b","d","key","round","__rowIds","__sortBy","createVisualizationData","type","xKey","prepareTextData","topTerms","texts","textColumn","vocabulary","tokens","seen","Set","docFreq","has","add","v","valueAggregation","getVocabulary","valueColumn","nDocs","useIdf","console","log","words","_ref","stats","tf","idf","importance","slice","minImportance","w","maxImportance","getTopTerms","self","onmessage","e","then","postMessage","status","catch","error"],"sourceRoot":""}